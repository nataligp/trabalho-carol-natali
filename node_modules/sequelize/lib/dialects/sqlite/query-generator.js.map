{
  "version": 3,
  "sources": ["../../../src/dialects/sqlite/query-generator.js"],
  "sourcesContent": ["'use strict';\n\nconst Utils = require('../../utils');\nconst Transaction = require('../../transaction');\nconst _ = require('lodash');\nconst MySqlQueryGenerator = require('../mysql/query-generator');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\n\nclass SQLiteQueryGenerator extends MySqlQueryGenerator {\n  createSchema() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  showSchemasQuery() {\n    return \"SELECT name FROM `sqlite_master` WHERE type='table' and name!='sqlite_sequence';\";\n  }\n\n  versionQuery() {\n    return 'SELECT sqlite_version() as `version`';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = options || {};\n\n    const primaryKeys = [];\n    const needsMultiplePrimaryKeys = Object.values(attributes).filter(definition => definition.includes('PRIMARY KEY')).length > 1;\n    const attrArray = [];\n\n    for (const attr in attributes) {\n      if (Object.prototype.hasOwnProperty.call(attributes, attr)) {\n        const dataType = attributes[attr];\n        const containsAutoIncrement = dataType.includes('AUTOINCREMENT');\n\n        let dataTypeString = dataType;\n        if (dataType.includes('PRIMARY KEY')) {\n          if (dataType.includes('INT')) {\n            // Only INTEGER is allowed for primary key, see https://github.com/sequelize/sequelize/issues/969 (no lenght, unsigned etc)\n            dataTypeString = containsAutoIncrement ? 'INTEGER PRIMARY KEY AUTOINCREMENT' : 'INTEGER PRIMARY KEY';\n\n            if (dataType.includes(' REFERENCES')) {\n              dataTypeString += dataType.substr(dataType.indexOf(' REFERENCES'));\n            }\n          }\n\n          if (needsMultiplePrimaryKeys) {\n            primaryKeys.push(attr);\n            if (dataType.includes('NOT NULL')) {\n              dataTypeString = dataType.replace(' PRIMARY KEY', '');\n            } else {\n              dataTypeString = dataType.replace('PRIMARY KEY', 'NOT NULL');\n            }\n          }\n        }\n        attrArray.push(`${this.quoteIdentifier(attr)} ${dataTypeString}`);\n      }\n    }\n\n    const table = this.quoteTable(tableName);\n    let attrStr = attrArray.join(', ');\n    const pkString = primaryKeys.map(pk => this.quoteIdentifier(pk)).join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, columns => {\n        if (columns.customIndex) {\n          attrStr += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    if (pkString.length > 0) {\n      attrStr += `, PRIMARY KEY (${pkString})`;\n    }\n\n    const sql = `CREATE TABLE IF NOT EXISTS ${table} (${attrStr});`;\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  booleanValue(value) {\n    return value ? 1 : 0;\n  }\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   */\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    // https://sqlite.org/json1.html\n    const jsonFunctionRegex = /^\\s*(json(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  //sqlite can't cast to datetime so we need to convert date values to their ISO strings\n  _toJSONValue(value) {\n    if (value instanceof Date) {\n      return value.toISOString();\n    }\n    if (Array.isArray(value) && value[0] instanceof Date) {\n      return value.map(val => val.toISOString());\n    }\n    return value;\n  }\n\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      return super.handleSequelizeMethod(smth, tableName, factory, options, prepend);\n    }\n\n    if (smth instanceof Utils.Cast) {\n      if (/timestamp/i.test(smth.type)) {\n        smth.type = 'datetime';\n      }\n    }\n\n    return AbstractQueryGenerator.prototype.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n\n  addColumnQuery(table, key, dataType) {\n    const attributes = {};\n    attributes[key] = dataType;\n    const fields = this.attributesToSQL(attributes, { context: 'addColumn' });\n    const attribute = `${this.quoteIdentifier(key)} ${fields[key]}`;\n\n    const sql = `ALTER TABLE ${this.quoteTable(table)} ADD ${attribute};`;\n\n    return this.replaceBooleanDefaults(sql);\n  }\n\n  showTablesQuery() {\n    return 'SELECT name FROM `sqlite_master` WHERE type=\\'table\\' and name!=\\'sqlite_sequence\\';';\n  }\n\n  updateQuery(tableName, attrValueHash, where, options, attributes) {\n    options = options || {};\n    _.defaults(options, this.options);\n\n    attrValueHash = Utils.removeNullValuesFromHash(attrValueHash, options.omitNull, options);\n\n    const modelAttributeMap = {};\n    const values = [];\n    const bind = [];\n    const bindParam = options.bindParam || this.bindParam(bind);\n\n    if (attributes) {\n      _.each(attributes, (attribute, key) => {\n        modelAttributeMap[key] = attribute;\n        if (attribute.field) {\n          modelAttributeMap[attribute.field] = attribute;\n        }\n      });\n    }\n\n    for (const key in attrValueHash) {\n      const value = attrValueHash[key];\n\n      if (value instanceof Utils.SequelizeMethod || options.bindParam === false) {\n        values.push(`${this.quoteIdentifier(key)}=${this.escape(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' })}`);\n      } else {\n        values.push(`${this.quoteIdentifier(key)}=${this.format(value, modelAttributeMap && modelAttributeMap[key] || undefined, { context: 'UPDATE' }, bindParam)}`);\n      }\n    }\n\n    let query;\n    const whereOptions = { ...options, bindParam };\n\n    if (options.limit) {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${this.whereQuery(where, whereOptions)} LIMIT ${this.escape(options.limit)})`;\n    } else {\n      query = `UPDATE ${this.quoteTable(tableName)} SET ${values.join(',')} ${this.whereQuery(where, whereOptions)}`;\n    }\n\n    return { query, bind };\n  }\n\n  truncateTableQuery(tableName, options = {}) {\n    return [\n      `DELETE FROM ${this.quoteTable(tableName)}`,\n      options.restartIdentity ? `; DELETE FROM ${this.quoteTable('sqlite_sequence')} WHERE ${this.quoteIdentifier('name')} = ${Utils.addTicks(Utils.removeTicks(this.quoteTable(tableName), '`'), \"'\")};` : ''\n    ].join('');\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    _.defaults(options, this.options);\n\n    let whereClause = this.getWhereConditions(where, null, model, options);\n\n    if (whereClause) {\n      whereClause = `WHERE ${whereClause}`;\n    }\n\n    if (options.limit) {\n      whereClause = `WHERE rowid IN (SELECT rowid FROM ${this.quoteTable(tableName)} ${whereClause} LIMIT ${this.escape(options.limit)})`;\n    }\n\n    return `DELETE FROM ${this.quoteTable(tableName)} ${whereClause}`;\n  }\n\n  attributesToSQL(attributes) {\n    const result = {};\n    for (const name in attributes) {\n      const dataType = attributes[name];\n      const fieldName = dataType.field || name;\n\n      if (_.isObject(dataType)) {\n        let sql = dataType.type.toString();\n\n        if (Object.prototype.hasOwnProperty.call(dataType, 'allowNull') && !dataType.allowNull) {\n          sql += ' NOT NULL';\n        }\n\n        if (Utils.defaultValueSchemable(dataType.defaultValue)) {\n          // TODO thoroughly check that DataTypes.NOW will properly\n          // get populated on all databases as DEFAULT value\n          // i.e. mysql requires: DEFAULT CURRENT_TIMESTAMP\n          sql += ` DEFAULT ${this.escape(dataType.defaultValue, dataType)}`;\n        }\n\n        if (dataType.unique === true) {\n          sql += ' UNIQUE';\n        }\n\n        if (dataType.primaryKey) {\n          sql += ' PRIMARY KEY';\n\n          if (dataType.autoIncrement) {\n            sql += ' AUTOINCREMENT';\n          }\n        }\n\n        if (dataType.references) {\n          const referencesTable = this.quoteTable(dataType.references.model);\n\n          let referencesKey;\n          if (dataType.references.key) {\n            referencesKey = this.quoteIdentifier(dataType.references.key);\n          } else {\n            referencesKey = this.quoteIdentifier('id');\n          }\n\n          sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n\n          if (dataType.onDelete) {\n            sql += ` ON DELETE ${dataType.onDelete.toUpperCase()}`;\n          }\n\n          if (dataType.onUpdate) {\n            sql += ` ON UPDATE ${dataType.onUpdate.toUpperCase()}`;\n          }\n\n        }\n\n        result[fieldName] = sql;\n      } else {\n        result[fieldName] = dataType;\n      }\n    }\n\n    return result;\n  }\n\n  showIndexesQuery(tableName) {\n    return `PRAGMA INDEX_LIST(${this.quoteTable(tableName)})`;\n  }\n\n  showConstraintsQuery(tableName, constraintName) {\n    let sql = `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}'`;\n\n    if (constraintName) {\n      sql += ` AND sql LIKE '%${constraintName}%'`;\n    }\n\n    return `${sql};`;\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX IF EXISTS ${this.quoteIdentifier(indexName)}`;\n  }\n\n  describeTableQuery(tableName, schema, schemaDelimiter) {\n    const table = {\n      _schema: schema,\n      _schemaDelimiter: schemaDelimiter,\n      tableName\n    };\n    return `PRAGMA TABLE_INFO(${this.quoteTable(this.addSchema(table))});`;\n  }\n\n  describeCreateTableQuery(tableName) {\n    return `SELECT sql FROM sqlite_master WHERE tbl_name='${tableName}';`;\n  }\n\n  removeColumnQuery(tableName, attributes) {\n\n    attributes = this.attributesToSQL(attributes);\n\n    let backupTableName;\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    // Temporary table cannot work for foreign keys.\n    return `${this.createTableQuery(backupTableName, attributes)\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};${\n        this.createTableQuery(tableName, attributes)\n      }INSERT INTO ${quotedTableName} SELECT ${attributeNames} FROM ${quotedBackupTableName};`\n      + `DROP TABLE ${quotedBackupTableName};`;\n  }\n\n  _alterConstraintQuery(tableName, attributes, createTableSql) {\n    let backupTableName;\n\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNames = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    return `${createTableSql\n      .replace(`CREATE TABLE ${quotedTableName}`, `CREATE TABLE ${quotedBackupTableName}`)\n      .replace(`CREATE TABLE ${quotedTableName.replace(/`/g, '\"')}`, `CREATE TABLE ${quotedBackupTableName}`)\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNames} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};`\n      + `ALTER TABLE ${quotedBackupTableName} RENAME TO ${quotedTableName};`;\n  }\n\n  renameColumnQuery(tableName, attrNameBefore, attrNameAfter, attributes) {\n\n    let backupTableName;\n\n    attributes = this.attributesToSQL(attributes);\n\n    if (typeof tableName === 'object') {\n      backupTableName = {\n        tableName: `${tableName.tableName}_backup`,\n        schema: tableName.schema\n      };\n    } else {\n      backupTableName = `${tableName}_backup`;\n    }\n\n    const quotedTableName = this.quoteTable(tableName);\n    const quotedBackupTableName = this.quoteTable(backupTableName);\n    const attributeNamesImport = Object.keys(attributes).map(attr =>\n      attrNameAfter === attr ? `${this.quoteIdentifier(attrNameBefore)} AS ${this.quoteIdentifier(attr)}` : this.quoteIdentifier(attr)\n    ).join(', ');\n    const attributeNamesExport = Object.keys(attributes).map(attr => this.quoteIdentifier(attr)).join(', ');\n\n    // Temporary tables don't support foreign keys, so creating a temporary table will not allow foreign keys to be preserved\n    return `${this.createTableQuery(backupTableName, attributes)\n    }INSERT INTO ${quotedBackupTableName} SELECT ${attributeNamesImport} FROM ${quotedTableName};`\n      + `DROP TABLE ${quotedTableName};${\n        this.createTableQuery(tableName, attributes)\n      }INSERT INTO ${quotedTableName} SELECT ${attributeNamesExport} FROM ${quotedBackupTableName};`\n      + `DROP TABLE ${quotedBackupTableName};`;\n  }\n\n  startTransactionQuery(transaction) {\n    if (transaction.parent) {\n      return `SAVEPOINT ${this.quoteIdentifier(transaction.name)};`;\n    }\n\n    return `BEGIN ${transaction.options.type} TRANSACTION;`;\n  }\n\n  setIsolationLevelQuery(value) {\n    switch (value) {\n      case Transaction.ISOLATION_LEVELS.REPEATABLE_READ:\n        return '-- SQLite is not able to choose the isolation level REPEATABLE READ.';\n      case Transaction.ISOLATION_LEVELS.READ_UNCOMMITTED:\n        return 'PRAGMA read_uncommitted = ON;';\n      case Transaction.ISOLATION_LEVELS.READ_COMMITTED:\n        return 'PRAGMA read_uncommitted = OFF;';\n      case Transaction.ISOLATION_LEVELS.SERIALIZABLE:\n        return '-- SQLite\\'s default isolation level is SERIALIZABLE. Nothing to do.';\n      default:\n        throw new Error(`Unknown isolation level: ${value}`);\n    }\n  }\n\n  replaceBooleanDefaults(sql) {\n    return sql.replace(/DEFAULT '?false'?/g, 'DEFAULT 0').replace(/DEFAULT '?true'?/g, 'DEFAULT 1');\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuÜ m> #®    Ü m›$ƒ    Ü mÀ &‡    Ü mÅ'¸    Ü mâ)Ä    Ü mê,,Ä    Ü > /HÄ    Ü tô0hÄ    Ü }« 1ÄÄ    Ü ê¨ 1úÄ    Ü ê†1ËÄ    ∆ ¯¨ 3Å    Ü ¯3 Å    Ü ¯†4<Å    Ü ¯|6$Ç    Ü °¨ 9@Ç    Ü °†9àÇ    Ü Ø« ;†Ç    Ñ Ø¶;»Ç    Ñ »—<ËÇ    Ñ ·´>É    Å Ï´?8É    ÑX	+ @\É    ∆˛±BpÉ    ÜX	+ CàÉ    ∆ ˛±E®É    ÜX	_FƒÉ    ∆ ˛±IÉ    ÜX	›JÑ    ∆ºLDÑ    ëuÒ N\Ñ    ÜX	
 NpÑ    ÜX	
 NúÑ    ∆C∆N∏Ñ    ∆R PÃÑ    ∆cÕPÖ    ∆b_QDÖ    ∆m QlÖ    ∆q˙QîÖ    ∆q RºÖ    ∆v
 S–Ö    ∆|˙S‰Ö    ∆| T Ü    ÜX	
 UÜ    ÜX	+ U,Ü    Ü É> W@Ü    Ü å« XTÜ    ∆ ¯¨ X‰Ü    ÜX	
 Xá    ∆>K X(á    ∆E—X<á    ∆œ
 Xlá    ∆S‹XÑá    ∆`·Yòá    ≈k‹Y»á    ∆k„[ à    ≈q‹]0à    ñ ßÒ _Tà    ∆≠È_tà    ∆≠ `òà    ∆π aºà    ∆9b–à    ∆Q
 c‰à    ∆G d â    ∆W
 e0â    ∆cÏe¥â    ∆kÏg8ä    ëuÒ iPä    ∆o
 idä    ÜX	
 iÄä    ÜX	> i®ä    ∆±¯j–ä    ÜX	
 kËä    ÜX		kã    ÜX	> l,ã    ∆±> mhã    ∆‹nåã    ∆‡≈oÙã    ë Îpå    ∆Û
 q<å    ∆Û> q|å    ∆’ r‰å    ∆˘« r8ç    ∆ h« rPç    ∆ 	ré    ∆ > sTé    ∆tåé    ∆0u¿é    ∆
u‡é    ∆
 uè    ∆> u,è    ∆›vlè    Å (˚xÄè    ñ 7"y†è    ∆:zƒè    ∆=≈{0ê    ∆G> |pê    Å N> }¨ê    ∆¶« ~ƒê    ∆V« ~‹ê    ∆h)~¸ê    ∆o≈Dë    ∆0Äàë    ∆á5Äúë    ∆ ¯¨ Ä¥ë    ∆¯Äí    ∆¯:Å‡í    ∆ï¨ Étì    ∆©¨ É–ì    ë πAÉ‡ì    ëuÒ ÑÙì    ÜX	
 Ñî    ÜX	> Ñ$î    ∆	ö« Ö8î    ∆	£> ÖLî    É ƒ> Ü      ∆“‹á      ∆Œ‹à`î    Å ›
 â|î    ∆Wâîî    ÜX	∏ä∏î    ÜX	æã‹î    ∆âóå¯î    ∆ Kçï    ∆úûé0ï    ∆Æ•èLï    ∆≈¨êhï    ∆‹≥ëÑï    ∆˘∫í†ï    ∆¡ìºï    ∆ §
 îñ    ≈, ›î8ñ    ≈: ›ñhñ    ≈G Ròòñ    ≈f 
 õƒñ    ≈É 
 õñ    ≈° 
 õó    ∆“‹õ4ó    ∆Œ‹úLó    ∆¡ 
 ù¨ó    ∆n0ùƒó    ∆ ‘4ùËó    ≈ a◊û¸ó    ∆ k> üÄò    ∆ k≈†ô    ∆ k °»ô    ∆ q> ¢Lö    ∆ z›£Ùö    ∆ Ö
 •õ    ∆}ó•4õ    ∆À K¶Põ    ∆ìûßlõ    ∆®•®àõ    ∆¬¨©§õ    ∆‹≥™¿õ    ∆¸∫´‹õ    ∆¡¨¯õ    ∆≠Y≠ú    ∆ ≠ Æ8ú    ∆ π ØXú    ∆· 
 ∞hú    ∆ 
 ∞®ú    ∆	˜ `∞¿ú    ∆	!∞‘ú    ÜX	∏±ù    ∆@!j≤ ù    ∆ §,≥Äù    ∆ ¨> ≥úù    ∆n0¥∞ù    ∆ À0¥»ù    ∆ ‘4¥¯ù    ∆ ◊« µ û    ∆W!jµDû    ∆ ‹> ∂lû    ÜX	
 ∑Äû    ÜX	> ∑îû    ∆	ê!« ∏®û    ∆	ù!> ∏ºû    ∆ƒ›πÿû    ÜX	
 ªÏû    ÜX	zªü    ∆	—!,æü    ∆	⁄!Zæ0ü    ∆	„!« øDü    ∆	˜!> øXü    É ƒz¿|ü    ∆ ¯¨ √‰ü    ∆	˜ `√¯ü    ÜX	ä√ †    ∆@!jƒP†    ∆a"Z≈x†    ∆m"è∆°    ∆w"ó»î°    ∆Ç"û º°    ∆â"> ÃË°    ∆í"> Õ¢    ≈«§ŒÄ¢    ∆ù"
 œú¢    ∆W!jœ      ∆Æ"™–      ∆«
 “      ∆∫"≤“      ∆Õ"≤‘      ∆€"≤÷      ∆Î"≤ÿÃ¢    ∆Æ"™⁄‹¢    ∆∫"≤‹Ï¢    ∆Õ"≤ﬁ¸¢    ∆€"≤‡£    ∆Î"≤‚£    ∆«
 ‰,£    ÑX	
 ‰@£    ∆˝"≤‰X£    ∆ ∫"≤Êp£    ∆ Õ"≤Ëà£    ∆ €"≤Í†£    ∆ Î"≤Ï∏£    ÜX	
 ÓÃ£    Å ›
 ÓË£    ∆ WÓ §    ÜX	> Ô$§    ÜX	˝H§    ÜX	Úl§    ÜX	Ùê§    ∆ âóˆ¨§    ∆ úû˜»§    ∆ Æ•¯‰§    ∆ ≈¨˘ •    ∆ ‹≥˙•    ∆ ˘∫˚8•    ∆ ¡¸T•    ∆ §
 ˝Ä•    ≈, ›˝∞•    ≈: ›ˇ‡•    ≈G R¶    ≈f 
 <¶    ≈É 
 h¶    ≈° 
 î¶    ∆“‹¨¶    ∆Œ‹ƒ¶    ∆¡ 
 $ß    ∆ n0<ß    ∆##0Xß    ∆ ‘˚|ß    ∆ k> ®    ∆ k≈ê®    ∆ q> 	©    ∆ }ó
8©    ∆ ìûT©    ∆ ®•p©    ∆ ¬¨å©    ∆ ‹≥®©    ∆ ¸∫ƒ©    ∆ ¡‡©    ∆ ≠È ™    ∆ ≠  ™    ∆ π @™    ∆· ˆX™    ∆· ˙p™    ≈· »0´    ∆ 
 p´    ÜX	
 Ñ´    ÜX	+ †´    ∆	.#¨ ¥´    ∆	7# »´    É ƒ+ ‰´    ∆ ¯¨  ¨    ëuÒ       ∆≠ø      ∆πø<¨    ∆Æ"™!L¨    ∆«
 #\¨    ∆≠ø#l¨    ∆πø%|¨    ÜX	
 'ê¨    ÜX	
 '§¨    ÜX	> '¿¨    ∆	Y#« (‘¨    ∆	b#> (Ë¨    ∆ ¯¨ )      ∆v#«)      ∆Å#œ+      ∆ú#◊-      ∆®#◊/      ∆∑#◊1      ∆∆#◊3      ∆ÿ#ﬂ5      ∆Ê#ﬂ7      ∆Ô#™9      ∆˘#™;      ∆$Á=      ∆$Á?      ∆5$ÁA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",
  "names": []
}
