<?xml version="1.0" encoding="us-ascii"?>
<doc>
  <assembly>
    <name>Microsoft.IdentityModel.Logging</name>
  </assembly>
  <members>
    <member name="T:Microsoft.IdentityModel.Logging.IdentityModelEventSource">
      <summary>
            Event source based logger to log different events.
            </summary>
    </member>
    <member name="P:Microsoft.IdentityModel.Logging.IdentityModelEventSource.Logger">
      <summary>
            Static logger that is exposed externally. An external application or framework can hook up a listener to this event source to log data in a custom way.
            </summary>
    </member>
    <member name="P:Microsoft.IdentityModel.Logging.IdentityModelEventSource.ShowPII">
      <summary>
            Flag which indicates whether or not PII is shown in logs. False by default.
            </summary>
    </member>
    <member name="P:Microsoft.IdentityModel.Logging.IdentityModelEventSource.HiddenPIIString">
      <summary>
            String that is used in place of any arguments to log messages if the 'ShowPII' flag is set to false.
            </summary>
    </member>
    <member name="P:Microsoft.IdentityModel.Logging.IdentityModelEventSource.HeaderWritten">
      <summary>
            Indicates whether or the log message header (contains library version, date/time, and PII debugging information) has been written.
            </summary>
    </member>
    <member name="F:Microsoft.IdentityModel.Logging.IdentityModelEventSource._versionLogMessage">
      <summary>
            The log message that indicates the current library version.
            </summary>
    </member>
    <member name="F:Microsoft.IdentityModel.Logging.IdentityModelEventSource._dateLogMessage">
      <summary>
            The log message that indicates the date.
            </summary>
    </member>
    <member name="F:Microsoft.IdentityModel.Logging.IdentityModelEventSource._piiOffLogMessage">
      <summary>
            The log message that is shown when PII is off.
            </summary>
    </member>
    <member name="F:Microsoft.IdentityModel.Logging.IdentityModelEventSource._piiOnLogMessage">
      <summary>
            The log message that is shown when PII is off.
            </summary>
    </member>
    <member name="M:Microsoft.IdentityModel.Logging.IdentityModelEventSource.WriteAlways(System.String)">
      <summary>
            Writes an event log by using the provided string argument and current UTC time.
            No level filtering is done on the event.
            </summary>
      <param name="message">The log message.</param>
      <remarks>No level filtering.</remarks>
    </member>
    <member name="M:Microsoft.IdentityModel.Logging.IdentityModelEventSource.WriteAlways(System.String,System.Object[])">
      <summary>
            Writes an event log by using the provided string argument, current UTC time and the provided arguments list.
            </summary>
      <param name="message">The log message.</param>
      <param name="args">An object array that contains zero or more objects to format.</param>
    </member>
    <member name="M:Microsoft.IdentityModel.Logging.IdentityModelEventSource.WriteVerbose(System.String)">
      <summary>
            Writes a verbose event log by using the provided string argument and current UTC time.
            </summary>
      <param name="message">The log message.</param>
    </member>
    <member name="M:Microsoft.IdentityModel.Logging.IdentityModelEventSource.WriteVerbose(System.String,System.Object[])">
      <summary>
            Writes a verbose event log by using the provided string argument, current UTC time and the provided arguments list.
            </summary>
      <param name="message">The log message.</param>
      <param name="args">An object array that contains zero or more objects to format.</param>
    </member>
    <member name="M:Microsoft.IdentityModel.Logging.IdentityModelEventSource.WriteInformation(System.String)">
      <summary>
            Writes an inf
      jake.exec([cmd], function () {
        complete();
      }, {printStdout: true});
    });

    desc('This rule has a namespace.');
    task('default', ['debug:obj/main.o]);

    namespace('debug', {async: true}, function() {
      rule('obj/%.o', 'src/%.c', function () {
        // ...
      });
    }
   */
  this.rule = function () {
    let args = Array.prototype.slice.call(arguments);
    let arg;
    let pattern = args.shift();
    let source = args.shift();
    let prereqs = [];
    let action = function () {};
    let opts = {};
    let key = pattern.toString(); // May be a RegExp

    while ((arg = args.shift())) {
      if (typeof arg == 'function') {
        action = arg;
      }
      else if (Array.isArray(arg)) {
        prereqs = arg;
      }
      else {
        opts = arg;
      }
    }

    jake.currentNamespace.rules[key] = new jake.Rule({
      pattern: pattern,
      source: source,
      prereqs: prereqs,
      action: action,
      opts: opts,
      desc: jake.currentTaskDescription,
      ns: jake.currentNamespace
    });
    jake.currentTaskDescription = null;
  };

  /**
    @name directory
    @static
    @function
    @description Creates a Jake DirectoryTask. Can be used as a prerequisite
    for FileTasks, or for simply ensuring a directory exists for use with a
    Task's action.
    `
    @param {String} name The name of the DiretoryTask

    @example

    // Creates the package directory for distribution
    directory('pkg');
   */
  this.directory = function (name) {
    let args = Array.prototype.slice.call(arguments);
    let createdTask;
    args.unshift('directory');
    createdTask = jake.createTask.apply(global, args);
    jake.currentTaskDescription = null;
    return createdTask;
  };

  /**
    @name file
    @static
    @function
    @description Creates a Jake FileTask.
    `
    @param {String} name The name of the FileTask
    @param {Array} [prereqs] Prerequisites to be run before this task
    @param {Function} [action] The action to create this file, if it doesn't
    exist already.
    @param {Object} [opts]
      @param {Array} [opts.asyc=false] Perform this task asynchronously.
      If you flag a task with this option, you must call the global
      `complete` method inside the task's action, for execution to proceed
      to the next task.

   */
  this.file = function (name, prereqs, action, opts) {
    let args = Array.prototype.slice.call(arguments);
    let createdTask;
    args.unshift('file');
    createdTask = jake.createTask.apply(global, args);
    jake.currentTaskDescription = null;
    return createdTask;
  };

  /**
    @name desc
    @static
    @function
    @description Creates a description for a Jake Task (or FileTask,
    DirectoryTask). When invoked, the description that iscreated will
    be associated with whatever Task is created next.
    `
    @param {String} description The description for the Task
   */
  this.desc = function (description) {
    jake.currentTaskDescription = description;
  };

  /**
    @name namespace
    @static
    @function
    @description Creates a namespace which allows logical grouping
    of tasks, and prevents name-collisions with task-names. Namespaces
    can be nested inside of other namespaces.
    `
    @param {String} name The name of the namespace
    @param {Function} scope The enclosing scope for the namespaced tasks

    @example
    namespace('doc', function () {
      task('generate', ['doc:clobber'], function () {
        // Generate some docs
      });

      task('clobber', function () {
        // Clobber the doc directory first
      });
    });
   */
  this.namespace = function (name, closure) {
    let curr = jake.currentNamespace;
    let ns = curr.childNamespaces[name] || new jake.Namespace(name, curr);
    let fn = closure || function () {};
    curr.childNamespaces[name] = ns;
    jake.currentNamespace = ns;
    fn();
    jake.currentNamespace = curr;
    jake.currentTaskDescription = null;
    return ns;
  };

  /**
    @name complete
    @static
    @function
    @description Completes an asynchronous task, allowing Jake's
    execution to proceed to the next task. Calling complete globally or without
    arguments completes the last task on the invocationChain. If you use parallel
    execution of prereqs this will probably complete a wrong task. You should call this
    function with this task as the first argument, before the optional return value.
    Alternatively you can call task.complete()
    `
    @example
    task('generate', ['doc:clobber'], function () {
      exec('./generate_docs.sh', function (err, stdout, stderr) {
        if (err || stderr) {
          fail(err || stderr);
        }
        else {
          console.log(stdout);
          complete();
        }
      });
    }, {async: true});
   */
  this.complete = function (task, val) {
    //this should detect if the first arg is a task, but I guess it should be more thorough
    if(task && task. _currentPrereqIndex >=0 ) {
      task.complete(val);
    }
    else {
      val = task;
      if(jake._invocationChain.length > 0) {
        jake._invocationChain[jake._invocationChain.length-1].complete(val);
      }
    }
  };

  /**
    @name fail
    @static
    @function
    @description Causes Jake execution to abort with an error.
    Allows passing an optional error code, which will be used to
    set the exit-code of exiting process.
    `
    @param {Error|String} err The error to thow when aborting execution.
    If this argument is an Error object, it will simply be thrown. If
    a String, it will be used as the error-message. (If it is a multi-line
    String, the first line will be used as the Error message, and the
    remaining lines will be used as the error-stack.)

    @example
    task('createTests, function () {
      if (!fs.existsSync('./tests')) {
        fail('Test directory does not exist.');
      }
      else {
        // Do some testing stuff ...
      }
    });
   */
  this.fail = function (err, code) {
    let msg;
    let errObj;
    if (code) {
      jake.errorCode = code;
    }
    if (err) {
      if (typeof err == 'string') {
        // Use the initial or only line of the error as the error-message
        // If there was a multi-line error, use the rest as the stack
        msg = err.split('\n');
        errObj = new Error(msg.shift());
        if (msg.length) {
          errObj.stack = msg.join('\n');
        }
        throw errObj;
      }
      else if (err instanceof Error) {
        throw err;
      }
      else {
        throw new Error(err.toString());
      }
    }
    else {
      throw new Error();
    }
  };

  this.packageTask = function (name, version, prereqs, definition) {
    return new jake.PackageTask(name, version, prereqs, definition);
  };

  this.publishTask = function (name, prereqs, opts, definition) {
    return new jake.PublishTask(name, prereqs, opts, definition);
  };

  // Backward-compat
  this.npmPublishTask = function (name, prereqs, opts, definition) {
    return new jake.PublishTask(name, prereqs, opts, definition);
  };

  this.testTask = function () {
    let ctor = function () {};
    let t;
    ctor.prototype = jake.TestTask.prototype;
    t = new ctor();
    jake.TestTask.apply(t, arguments);
    return t;
  };

  this.setTaskTimeout = function (t) {
    this._taskTimeout = t;
  };

  this.setSeriesAutoPrefix = function (prefix) {
    this._seriesAutoPrefix = prefix;
  };

  this.series = function (...args) {
    let prereqs = args.map((arg) => {
      let name = (this._seriesAutoPrefix || '') + arg.name;
      jake.task(name, arg);
      return name;
    });
    let seriesName = uuid();
    let seriesTask = jake.task(seriesName, prereqs);
    seriesTask._internal = true;
    let res = function () {
      return new Promise((resolve) => {
        seriesTask.invoke();
        seriesTask.on('complete', (val) => {
          resolve(val);
        });
      });
    };
    Object.defineProperty(res, 'name', {value: uuid(),
      writable: false});
    return res;
  };

})();

module.exports = api;
